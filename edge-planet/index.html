<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <title></title>
    <style>body, html {
        width: 100%;
        height: 100%;
        margin: 0;
        overflow: hidden;
    }</style>
</head>
<body>
<script src="js/gl-matrix-min.js"></script>
<script src="js/utils.js"></script>
<script src="js/webgl-utils.js"></script>
<script>
    'use strict';

    window.canvas = document.createElement('canvas');
    document.body.appendChild(canvas);
    window.gl = canvas.getContext('webgl', {antialias: false});

    var dWidth, dHeight;

    var resizeCanvas = function () {
        dWidth = parseFloat(document.body.clientWidth);
        dHeight = parseFloat(document.body.clientHeight);
        canvas.width = dWidth;
        canvas.height = dHeight;
    };

    resizeCanvas();

    window.frameRate = document.createElement('div');
    frameRate.setAttribute('style', 'position: fixed; bottom: 50px; left: 20px; color: #fff');
    document.body.appendChild(frameRate);

    var cube;
    var rotationMatrixUniform;

    var pr;
    var initShaders = function () {
        return glu.loadProgram('shaders/vshader.glsl', 'shaders/fshader.glsl').then(function (program) {
            pr = program;
            gl.useProgram(pr);

            pr.aVertexPos = gl.getAttribLocation(pr, "aVertexPos");
            pr.aVertexNormal = gl.getAttribLocation(pr, "aVertexNormal");
            pr.uPMat = gl.getUniformLocation(pr, "uPMat");
            pr.uColor = gl.getUniformLocation(pr, "uColor");
            pr.uLight = gl.getUniformLocation(pr, "uLight");
            pr.uPos = gl.getUniformLocation(pr, "uPos");
        });
    };

    var Cube = function (size) {

        // cube ///////////////////////////////////////////////////////////////////////
        //    v6------v5
        //   /|      /|
        //  v1------v0|
        //  | |     | |
        //  | |v7---|-|v4
        //  |/      |/
        //  v2------v3

        var i;
        this.vertices = [
            -1, -1,  1,   0,  0,  1, //vertex normal
             1, -1,  1,   0,  0,  1, //vertex normal
            -1,  1,  1,   0,  0,  1, //vertex normal
             1,  1,  1,   0,  0,  1, //vertex normal
            -1,  1,  1,   0,  1,  0, //vertex normal
             1,  1,  1,   0,  1,  0, //vertex normal
            -1,  1, -1,   0,  1,  0, //vertex normal
             1,  1, -1,   0,  1,  0, //vertex normal
            -1,  1, -1,   0,  0, -1, //vertex normal
             1,  1, -1,   0,  0, -1, //vertex normal
            -1, -1, -1,   0,  0, -1, //vertex normal
             1, -1, -1,   0,  0, -1, //vertex normal
            -1, -1, -1,   0, -1,  0, //vertex normal
             1, -1, -1,   0, -1,  0, //vertex normal
            -1, -1,  1,   0, -1,  0, //vertex normal
             1, -1,  1,   0, -1,  0, //vertex normal
             1, -1,  1,   1,  0,  0, //vertex normal
             1, -1, -1,   1,  0,  0, //vertex normal
             1,  1,  1,   1,  0,  0, //vertex normal
             1,  1, -1,   1,  0,  0, //vertex normal
            -1, -1, -1,  -1,  0,  0, //vertex normal
            -1, -1,  1,  -1,  0,  0, //vertex normal
            -1,  1, -1,  -1,  0,  0, //vertex normal
            -1,  1,  1,  -1,  0,  0, //vertex normal
        ];
        this.indices = [0, 1, 2, 2, 1, 3, 4, 5, 6, 6, 5, 7, 8, 9, 10, 10, 9, 11, 12, 13, 14, 14, 13, 15, 16, 17, 18, 18, 17, 19, 20, 21, 22, 22, 21, 23];

        var len = this.vertices.length;
        for (i = 0; i < len; i++) {
            if (i % 6 < 3) {
                this.vertices[i] *= size;
            }
        }
    };

    Cube.prototype.normalCoeff = 1 / Math.sqrt(3);

    var initBuffers = function () {

        cube = new Cube(1 / 64);

        cube.vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cube.vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cube.vertices), gl.STATIC_DRAW);

        cube.indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cube.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(cube.indices), gl.STATIC_DRAW);
    };

    var resizeView = function () {
        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

        var b = 2048 / dHeight;
        var a = dHeight / dWidth;
        gl.uniformMatrix3fv(pr.uPMat, false, new Float32Array([
            +a * b, +0.5 * b, +1.0,
            +a * b, -0.5 * b, -1.0,
            +0.0, +1.0 * b, +0.0,
        ]));
    };

    var resize = function () {
        resizeCanvas();
        resizeView();
    };

    initBuffers();
    initShaders().then(function () {
        init();
        resizeView();
        window.addEventListener('resize', resize);
        window.addEventListener('keydown', onkey);
        window.addEventListener('keyup', onkey);
        requestAnimationFrame(draw);
    }, err);

    var init = function () {
        gl.clearColor(0.0, 0.06, 0.1, 1.0);
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cube.indexBuffer);

        gl.bindBuffer(gl.ARRAY_BUFFER, cube.vertexBuffer);

        gl.enableVertexAttribArray(pr.aVertexPos);
        gl.vertexAttribPointer(pr.aVertexPos, 3, gl.FLOAT, false, 24, 0);
        gl.enableVertexAttribArray(pr.aVertexNormal);
        gl.vertexAttribPointer(pr.aVertexNormal, 3, gl.FLOAT, false, 24, 12);

        var angle = Math.PI-0.1;
        gl.uniform3f(pr.uLight, Math.sin(angle) * coef, Math.cos(angle) * coef, coef);
    };

    var onkey = function (e) {
        log(e.keyCode, utils.keyLabels[e.keyCode]);
    };

    var coef = 1 / Math.sqrt(2);
    var _16 = 1 / 32;
    var ot, dt;
    var frame = 1;
    var zeta = 14;
    var teta = 8;
    var num = 10;
    var sqr = Math.floor(Math.sqrt(num));
    var frate = 0;

    var numColors = 7;
    var colors = new Float32Array(numColors * 3);
    for (var i = 0; i < numColors * 3; i++) {
        colors[i] = Math.random();
    }

    var draw = function (nt) {
        if (!ot) {
            ot = nt;
            requestAnimationFrame(draw);
            return;
        }
        dt = nt - ot;
        frame++;
        frame = frame % 11;
        if (frame) {
            frate += 1000 / dt;
        } else {
            frameRate.innerHTML = (frate / 10).toFixed(1);
            frate = 0;
        }

        requestAnimationFrame(draw);

        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        for (var i = 0; i < num; i++) {
            gl.uniform3fv(pr.uColor, colors.subarray(i % numColors, i % numColors + 3));
            gl.uniform3f(pr.uPos, (i % sqr - sqr / 2) * _16, Math.floor(i / sqr - sqr / 2) * _16, Math.floor(-i / 200) * _16);
            gl.drawElements(gl.TRIANGLES, cube.indices.length, gl.UNSIGNED_BYTE, 0);
        }
        ot = nt;
    };

</script>
</body>
</html>