<!DOCTYPE html>
<!-- saved from url=(0040)http://syntime.github.io/tree-trunk.html -->
<html lang="en" xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<meta charset="utf-8">
	<title></title>
	<style>
		body, html {
			width: 100%;
			height: 100%;
			margin: 0;
			overflow: hidden;
		}
	</style>
</head>
<body>
	<script>
		var canvas = document.createElement('canvas');
		var displayWidth = document.body.clientWidth;
		var displayHeight = document.body.clientHeight;

		var rate = 15;
		var lineWidth = 2;
		var cellSize = 4;
		var mazeWidth = Math.floor(displayWidth / cellSize - 1);
		var mazeHeight = Math.floor(displayHeight / cellSize - 1);

		//var forkThreshold = 0.05;
		//var rotateThreshold = 0.5;
		//var growThreshold = 0.8;

		var fork3Threshold = 0.2;

		canvas.setAttribute('width', displayWidth);
		canvas.setAttribute('height', displayHeight);
		canvas.style.display = "block";
		document.body.appendChild(canvas);
		var ctx = canvas.getContext('2d');

		ctx.fillStyle = '#000';
		ctx.fillRect(0, 0, displayWidth, displayHeight);
		ctx.lineWidth = lineWidth;

		function getRandomColor() {
			var letters = '0123456789ABCDEF'.split('');
			var color = '#';
			for (var i = 0; i < 6; i++) {
				color += letters[Math.floor(Math.random() * 16)];
			}
			return color;
		}

		var Maze = function (width, height) {
			this.width = width;
			this.height = height;
			this.arr = new Uint8Array(new ArrayBuffer(this.width * this.height * 4));
		};

		Maze.prototype.get = function (x, y) {
			if (x < 0 || x > this.width || y < 0 || y > this.height) return true;
			return this.arr[x + y * this.width];
		};

		Maze.prototype.set = function (x, y) {
			if (x < 0 || x > this.width || y < 0 || y > this.height) return;
			this.arr[x + y * this.width] = true;
		};

		function generateNodeType(_maze) {

			var Node = function (x, y, parent) {
				this.parent = parent;
				this.children = [];
				this.x = x;
				this.y = y;
				this.draw(this.parent, this);
			};

			Node.prototype.getCoords = function (count) {
				var coords = [[this.x + 1, this.y], [this.x - 1, this.y], [this.x, this.y + 1], [this.x, this.y - 1]];
				coords = coords.filter(function (e) { return !this.maze.get(e[0], e[1]) }, this);
				while (count < coords.length) {
					var i = Math.floor(Math.random() * coords.length);
					coords.splice(i, 1);
				}
				return coords;
			};

			Node.prototype.fork = function (ways) {
				var event = Math.random();

				var wayCount = ways || (event < fork3Threshold ? 3 : 2);
				var coords = this.getCoords(wayCount);
				coords.forEach(function (coord) {
					var node = new this.constructor(coord[0], coord[1], this);
					this.children.push(node);
					this.maze.set(coord[0], coord[1]);
				}, this);
				return this.children;
			};

			Node.prototype.grow = function () {
				var x, y;
				if (this.parent) {
					x = 2 * this.x - this.parent.x;
					y = 2 * this.y - this.parent.y;
				} else {
					var coords = this.getCoords(1);
					if (coords.length) {
						x = coords[0][0];
						y = coords[0][1];
					} else {
						return;
					}
				}
				if (this.maze.get(x, y)) {
					return this.rotate();
				} else {
					var node = new this.constructor(x, y, this);
					this.children.push(node);
					this.maze.set(x, y);
				}
				return this.children;
			};

			Node.prototype.rotate = function () {
				return this.fork(1);
			};

			Node.prototype.color = getRandomColor();

			Node.prototype.draw = function draw(node1, node2) {
				if (node1) {
					ctx.beginPath();
					ctx.strokeStyle = '#000';
					ctx.lineWidth = cellSize;
					ctx.moveTo(cellSize * node1.x + 1.5 * lineWidth, cellSize * node1.y + 1.5 * lineWidth);
					ctx.lineTo(cellSize * node2.x + 1.5 * lineWidth, cellSize * node2.y + 1.5 * lineWidth);
					ctx.stroke();

					ctx.beginPath();
					ctx.strokeStyle = this.color;
					ctx.lineWidth = lineWidth;
					ctx.moveTo(cellSize * node1.x + 1.5 * lineWidth, cellSize * node1.y + 1.5 * lineWidth);
					ctx.lineTo(cellSize * node2.x + 1.5 * lineWidth, cellSize * node2.y + 1.5 * lineWidth);
					ctx.stroke();
				} else {
					ctx.beginPath();
					ctx.strokeStyle = this.color;
					ctx.fillRect(node2.x * cellSize + 1.5 * lineWidth, node2.y * cellSize + 1.5 * lineWidth, cellSize, cellSize);
					ctx.arc(node2.x * cellSize + 1.5 * lineWidth, node2.y * cellSize + 1.5 * lineWidth, lineWidth, 0, 2 * Math.PI);
					ctx.stroke();
				}
			};

			Node.prototype.maze = _maze;

			return Node;
		}

        var maze = new Maze(mazeWidth, mazeHeight);

		var Tree = function (x, y) {
			this.forkThreshold = Math.random() * 0.5;
			this.forkThreshold *= this.forkThreshold;
			this.rotateThreshold = Math.random() * ((1 - this.forkThreshold) * 0.1);
			this.growThreshold = Math.random() * (1 - this.rotateThreshold);

			this.Node = generateNodeType(maze);
			this.ends = [];
			this.ends.push(new this.Node(x, y));
		};

		Tree.prototype.iterate = function iterate() {
			if (!this.ends.length) return;

			var event, children, newEnds = [];

			this.ends.forEach(function (end) {
				event = Math.random();
				if (event < this.forkThreshold) {
					children = end.fork();
				} else if (event < this.rotateThreshold) {
					children = end.rotate();
				} else if (event < this.growThreshold) {
					children = end.grow();
				} else {
					children = [end];
				}
				if (children.length) {
					newEnds = newEnds.concat(children);
				}
			}, this);

			this.ends = newEnds;

			setTimeout(this.iterate.bind(this), rate);
		};

		document.addEventListener('click', function (e) {
			var x = Math.floor(e.x / cellSize);
			var y = Math.floor(e.y / cellSize);
			var tree = new Tree(x, y);
			tree.iterate();
		});

	</script>
</body>
</html>
